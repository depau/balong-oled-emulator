#!/usr/bin/env python3
import argparse
import subprocess
import textwrap
from pathlib import Path

from PIL import Image, ImageFont, ImageDraw


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("font", type=Path, help="TTF/OTF font file")
    parser.add_argument("size", type=int, help="Font pixel size")
    parser.add_argument("out", type=Path, help="Output header path")
    parser.add_argument("--name", default="MyFont",
                        help="Base C++ identifier for the font")
    parser.add_argument("--replacement-char", default="â–¡",
                        help="Glyph used for control chars (ASCII < 32 or 127)")
    args = parser.parse_args()

    font = ImageFont.truetype(str(args.font), args.size)
    ascent, descent = font.getmetrics()
    line_gap = int(args.size * 0.2)

    # Pre-render replacement glyph once
    rep_char = args.replacement_char
    rep_mask = font.getmask(rep_char, mode="L")
    rep_bbox = rep_mask.getbbox() or (0, 0, 0, 0)

    glyphs = []
    bitmap_bytes = bytearray()

    # We keep a memo to reuse identical bitmaps (e.g. control codes)
    bitmap_cache = {}

    def render_char(ch: str):
        # First, detect whitespace / empty glyphs using a simple mask
        raw_mask = font.getmask(ch, mode="L")
        if not raw_mask.getbbox():
            # whitespace or non-drawing glyph
            return {
                "comment": ch.isprintable() and ch or f"#{ord(ch):02X}",
                "width": 0,
                "height": 0,
                "bearingX": 0,
                "bearingY": 0,
                "advance": font.getlength(ch),
                "bitmap": b"",
            }

        # Baseline-aware metrics: anchor "ls" = left side on baseline
        x0, y0, x1, y1 = font.getbbox(ch, mode="L", anchor="ls")

        # Bitmap aligned to the same anchor; top-left is (0, 0) in mask space
        mask = font.getmask(ch, mode="L", anchor="ls")
        gw, gh = mask.size

        # Convert mask to 8-bit alpha row-major
        bmp = bytearray()
        for y in range(gh):
            for x in range(gw):
                v = mask.getpixel((x, y))  # mask-local coords
                bmp.append(v)

        adv = int(round(font.getlength(ch)))
        return {
            "comment": ch.isprintable() and ch or f"#{ord(ch):02X}",
            "width": gw,
            "height": gh,
            "bearingX": x0,
            # distance from baseline up to the top of the bitmap (positive)
            "bearingY": -y0,
            "advance": adv,
            "bitmap": bytes(bmp),
        }

    for code in range(128):
        if code < 32 or code == 127:
            ch = rep_char
        else:
            ch = chr(code)

        g = render_char(ch)

        key = (g["width"], g["height"], g["bearingX"], g["bearingY"], g["advance"], g["bitmap"])
        if key in bitmap_cache:
            offset = bitmap_cache[key]
        else:
            offset = len(bitmap_bytes)
            bitmap_bytes.extend(g["bitmap"])
            bitmap_cache[key] = offset

        glyphs.append({
            "comment": g["comment"],
            "width": g["width"],
            "height": g["height"],
            "bearingX": g["bearingX"],
            "bearingY": g["bearingY"],
            "advance": g["advance"],
            "offset": offset
        })

    # Emit header
    var_base = f"{args.name}_{args.size}".replace("-", "_")

    with args.out.open("w", encoding="utf-8") as f:
        f.write("// Generated by generate_bitmap_font.py\n")
        f.write("#pragma once\n\n")
        f.write("#include <cstdint>\n")
        f.write("#include \"clay_fb_renderer.hpp\" // BitmapFont, Glyph\n\n")
        f.write(f"namespace fonts {{\n\n")

        # Bitmap array
        f.write(f"inline constexpr std::uint8_t {var_base}_bitmap[] = {{ // 8bpp alpha\n")
        line = "    "
        for i, b in enumerate(bitmap_bytes):
            token = f"{b}, "
            if len(line) + len(token) > 80:
                f.write(line + "\n")
                line = "    "
            line += token
        if line.strip():
            f.write(line + "\n")
        f.write("};\n\n")

        # Glyphs
        f.write(f"inline constexpr Glyph {var_base}_glyphs[128] = {{\n")
        for g in glyphs:
            f.write(f" /* {g['comment']} */  {{")
            f.write(f"{g['width']}, {g['height']}, "
                    f"{g['bearingX']}, {g['bearingY']}, "
                    f"{int(round(g['advance'], 0))}, {g['offset']}")
            f.write("},\n")
        f.write("};\n\n")

        # Font instance
        f.write(f"inline constexpr BitmapFont {var_base} = {{\n")
        f.write(f"    \"{args.name}\", // font name\n")
        f.write(f"    {args.size}, // size\n")
        f.write(f"    {ascent}, // ascent\n")
        f.write(f"    -{descent}, // descent (negative)\n")
        f.write(f"    {line_gap}, // lineGap\n")
        f.write(f"    {var_base}_glyphs,\n")
        f.write(f"    {var_base}_bitmap\n")
        f.write("};\n\n")

        f.write("} // namespace fonts\n")

    subprocess.run(["clang-format", "-i", str(args.out)])
    print(f"Wrote {args.out}")


if __name__ == "__main__":
    main()
